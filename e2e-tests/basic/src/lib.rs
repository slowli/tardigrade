use futures::{FutureExt, StreamExt};
use serde::{Deserialize, Serialize};

use std::time::Duration;

use tardigrade::workflow::ValidateInterface;
use tardigrade::{
    channel::{Receiver, Sender},
    sleep, spawn,
    workflow::{
        InputsBuilder, Interface, ProvideInterface, PutHandle, TakeHandle, ValidationErrors,
        WithHandle,
    },
    Data, Json, SpawnWorkflow, TaskHandle,
};

#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum PizzaKind {
    Pepperoni,
    Margherita,
    FourCheese,
}

impl PizzaKind {
    fn baking_time(self) -> Duration {
        Duration::from_millis(match self {
            Self::Pepperoni => 50,
            Self::Margherita => 75,
            Self::FourCheese => 40,
        })
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub struct PizzaOrder {
    pub kind: PizzaKind,
    pub delivery_distance: u64,
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum DomainEvent {
    OrderTaken { index: usize, order: PizzaOrder },
    Baked { index: usize, order: PizzaOrder },
    StartedDelivering { index: usize, order: PizzaOrder },
    Delivered { index: usize, order: PizzaOrder },
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Inputs {
    pub oven_count: usize,
    pub deliverer_count: usize,
}

#[derive(Debug)]
// #[derive(ProvideInterface)] -> ProvideInterface + ValidateInterface + spec stub (if not present)
//    + link section + test
// #[derive(WithHandle)] -> PizzaDeliveryHandle<Env> () + WithHandle + TakeHandle + PutHandle
// #[derive(SpawnWorkflow)] -> SpawnWorkflow + entry point fn
pub struct PizzaDelivery {
    pub inputs: Data<Inputs, Json>,
    pub orders: Receiver<PizzaOrder, Json>,
    pub events: Sender<DomainEvent, Json>,
}

// Autogenerated
impl ProvideInterface for PizzaDelivery {
    fn interface() -> Interface<Self> {
        Interface::from_bytes(&__TARDIGRADE_SPEC)
            .downcast()
            .unwrap()
    }
}

impl SpawnWorkflow for PizzaDelivery {
    type Wasm = Handle<tardigrade::Wasm>;
}

// TODO: implement `Debug`, `Clone`, `Default` by-field
pub struct Handle<Env>
where
    Data<Inputs, Json>: WithHandle<Env>,
    Receiver<PizzaOrder, Json>: WithHandle<Env>,
    Sender<DomainEvent, Json>: WithHandle<Env>,
{
    pub inputs: <Data<Inputs, Json> as WithHandle<Env>>::Handle,
    pub orders: <Receiver<PizzaOrder, Json> as WithHandle<Env>>::Handle,
    pub events: <Sender<DomainEvent, Json> as WithHandle<Env>>::Handle,
}

impl<Env> WithHandle<Env> for PizzaDelivery
where
    Data<Inputs, Json>: WithHandle<Env>,
    Receiver<PizzaOrder, Json>: WithHandle<Env>,
    Sender<DomainEvent, Json>: WithHandle<Env>,
{
    type Handle = Handle<Env>;
}

impl<Env> TakeHandle<Env, ()> for PizzaDelivery
where
    Data<Inputs, Json>: TakeHandle<Env, &'static str>,
    Receiver<PizzaOrder, Json>: TakeHandle<Env, &'static str>,
    Sender<DomainEvent, Json>: TakeHandle<Env, &'static str>,
{
    fn take_handle(env: &mut Env, _id: ()) -> Self::Handle {
        Handle {
            inputs: <Data<Inputs, Json> as TakeHandle<Env, &'static str>>::take_handle(
                &mut *env, "inputs",
            ),
            orders: <Receiver<PizzaOrder, Json> as TakeHandle<Env, &'static str>>::take_handle(
                &mut *env, "orders",
            ),
            events: <Sender<DomainEvent, Json> as TakeHandle<Env, &'static str>>::take_handle(
                &mut *env, "events",
            ),
        }
    }
}

impl<Env> PutHandle<Env, ()> for PizzaDelivery
where
    Data<Inputs, Json>: PutHandle<Env, &'static str>,
    Receiver<PizzaOrder, Json>: PutHandle<Env, &'static str>,
    Sender<DomainEvent, Json>: PutHandle<Env, &'static str>,
{
    fn put_handle(env: &mut Env, _id: (), handle: Self::Handle) {
        <Data<Inputs, Json> as PutHandle<Env, &'static str>>::put_handle(
            &mut *env,
            "inputs",
            handle.inputs,
        );
        <Receiver<PizzaOrder, Json> as PutHandle<Env, &'static str>>::put_handle(
            &mut *env,
            "orders",
            handle.orders,
        );
        <Sender<DomainEvent, Json> as PutHandle<Env, &'static str>>::put_handle(
            &mut *env,
            "events",
            handle.events,
        );
    }
}

impl ValidateInterface<()> for PizzaDelivery {
    type Error = ValidationErrors;

    fn validate_interface(interface: &Interface<()>, _id: ()) -> Result<(), Self::Error> {
        let mut errors = ValidationErrors::default();
        if let Err(err) = <Data<Inputs, Json>>::validate_interface(interface, "inputs") {
            errors.insert_error("inputs", err);
        }
        if let Err(err) = <Receiver<PizzaOrder, Json>>::validate_interface(interface, "orders") {
            errors.insert_error("orders", err);
        }
        if let Err(err) = <Sender<DomainEvent, Json>>::validate_interface(interface, "events") {
            errors.insert_error("events", err);
        }
        errors.into_result()
    }
}

impl From<Handle<tardigrade::Wasm>> for TaskHandle {
    fn from(handle: Handle<tardigrade::Wasm>) -> Self {
        Self::new(handle.spawn())
    }
}

#[cfg_attr(target_arch = "wasm32", link_section = "__tardigrade_spec")]
#[doc(hidden)]
pub static __TARDIGRADE_SPEC: [u8; 315] = *include_bytes!("tardigrade.json");

#[cfg(all(target_arch = "wasm32", not(target_os = "emscripten")))]
#[no_mangle]
pub extern "C" fn __tardigrade_rt__main() -> TaskHandle {
    use tardigrade::Wasm;
    let workflow = <PizzaDelivery as TakeHandle<Wasm, ()>>::take_handle(&mut Wasm::default(), ());
    workflow.into()
}

// End autogenerated

impl From<Inputs> for Handle<InputsBuilder> {
    fn from(inputs: Inputs) -> Self {
        Self {
            inputs,
            orders: (),
            events: (),
        }
    }
}

impl Handle<tardigrade::Wasm> {
    pub async fn spawn(self) {
        let Self {
            inputs,
            orders,
            events,
        } = self;
        let inputs = inputs.into_inner();

        let mut counter = 0;
        let events_copy = events.clone();
        let baked_pizzas = orders
            .map(move |order| {
                counter += 1;
                spawn("baking", Self::bake(counter, order, events_copy.clone())).map(Result::unwrap)
                // propagate panics
            })
            .buffer_unordered(inputs.oven_count);

        baked_pizzas
            .map(move |(index, order)| {
                spawn("delivering", Self::deliver(index, order, events.clone())).map(Result::unwrap)
            })
            .buffer_unordered(inputs.deliverer_count)
            .for_each(|()| async { /* do nothing, just await */ })
            .await;
    }

    async fn bake(
        index: usize,
        order: PizzaOrder,
        mut events: Sender<DomainEvent, Json>,
    ) -> (usize, PizzaOrder) {
        events.send(DomainEvent::OrderTaken { index, order }).await;
        sleep("baking", order.kind.baking_time()).await;
        events.send(DomainEvent::Baked { index, order }).await;
        (index, order)
    }

    async fn deliver(index: usize, order: PizzaOrder, mut events: Sender<DomainEvent, Json>) {
        events
            .send(DomainEvent::StartedDelivering { index, order })
            .await;
        let delay = Duration::from_millis(order.delivery_distance * 100);
        sleep("delivery", delay).await;
        events.send(DomainEvent::Delivered { index, order }).await;
    }
}

#[test]
fn workflow_basics() {
    use tardigrade::{TestHandle, TestWorkflow};

    let inputs = Inputs {
        oven_count: 1,
        deliverer_count: 1,
    };

    PizzaDelivery::test(inputs.into(), |handle| async move {
        let TestHandle {
            mut interface,
            timers,
            ..
        } = handle;
        let order = PizzaOrder {
            kind: PizzaKind::Pepperoni,
            delivery_distance: 10,
        };
        interface.orders.send(order).await;

        let event = interface.events.next().await.unwrap();
        assert_eq!(event, DomainEvent::OrderTaken { index: 1, order });

        let now = timers.now();
        let updated_now = timers.advance_time_to_next_event();
        assert_eq!((updated_now - now).num_milliseconds(), 50);
        let event = interface.events.next().await.unwrap();
        assert_eq!(event, DomainEvent::Baked { index: 1, order });
    });
}
