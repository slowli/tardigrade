<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Workers for external tasks in Tardigrade runtime."><title>tardigrade_worker - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-47e7ab555ef2818a.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="tardigrade_worker" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0-nightly (62ebe3a2b 2023-09-08)" data-channel="nightly" data-search-js="search-5d3eaacf19ebf04f.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-f194925aa375ae96.css" data-theme-dark-css="dark-1dd4d1ce031e15de.css" data-theme-ayu-css="ayu-49e58d069f567085.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-ef3a2de404864b0b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-f194925aa375ae96.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1dd4d1ce031e15de.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../tardigrade_worker/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../tardigrade_worker/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate tardigrade_worker</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">tardigrade_worker</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/tardigrade_worker/lib.rs.html#1-496">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Workers for external tasks in Tardigrade runtime.</p>
<p>A worker represents a piece of functionality external to Tardigrade workflows.
A workflow can connect to the worker by specifying
the worker name in the relevant <a href="../tardigrade_shared/interface/struct.SenderSpec.html" title="struct tardigrade_shared::interface::SenderSpec">sender specification</a>.
A single worker can serve multiple workflows; i.e., it can be thought of as a server
in the client-server model, with workflows acting as clients. So far, workers
only implement the request-response communication pattern. Similar to modern RPC
protocols (e.g., gRPC), communication is non-blocking; multiple requests may be simultaneously
in flight. Concurrency restrictions, if desired, can be enforced on the workflow side
(see <code>channels::Requests</code>) and/or on the handler level. As with other Tardigrade components,
passing messages via channels leads to lax worker availability requirements; a worker
does not need to be highly available or work without failures.</p>
<h2 id="implementation-details"><a href="#implementation-details">Implementation details</a></h2>
<p>Internally, a <a href="struct.Worker.html" title="struct tardigrade_worker::Worker"><code>Worker</code></a> is implemented storing a <a href="struct.WorkerRecord.html" title="struct tardigrade_worker::WorkerRecord"><code>WorkerRecord</code></a> in the same database
as other runtime-related entities (e.g., workflows). Worker records maintain the mapping
between the (unique) worker name and the inbound channel for requests sent to the worker,
which is used by the runtime to resolve channels in the workflow interface specification.
Additionally, a worker record contains the cursor position for the inbound channel,
similar to message consumers in Kafka.</p>
<p>Workers poll new requests using a connection to the Tardigrade runtime, either
an in-process one, or a remote one via the gRPC service wrapper. This variability
is encapsulated in <a href="trait.WorkerStoragePool.html" title="trait tardigrade_worker::WorkerStoragePool">pool</a> and <a href="trait.WorkerStorageConnection.html" title="trait tardigrade_worker::WorkerStorageConnection">connection</a> traits.
In-process connections enable “exactly once” semantics for request handling; otherwise,
handling has “at least once” semantics (a request may be handled repeatedly if the worker
crashes during handling).</p>
<h2 id="examples"><a href="#examples">Examples</a></h2><h3 id="sequential-handler"><a href="#sequential-handler">Sequential handler</a></h3>
<p>In this simplest implementation, the worker processes requests sequentially. This allows
“exactly once” processing, but can be restricting in terms of throughput.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>SequentialHandler {
    <span class="comment">// fields snipped
</span>}

<span class="kw">impl </span>WorkerInterface <span class="kw">for </span>SequentialHandler {
    <span class="kw">type </span>Request = String;
    <span class="kw">type </span>Response = String;
    <span class="kw">type </span>Codec = Json;
}

<span class="attr">#[async_trait]
</span><span class="kw">impl</span>&lt;P: WorkerStoragePool&gt; HandleRequest&lt;P&gt; <span class="kw">for </span>SequentialHandler {
    <span class="kw">async fn </span>handle_request(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        request: Request&lt;<span class="self">Self</span>&gt;,
        connection: <span class="kw-2">&amp;mut </span>P::Connection&lt;<span class="lifetime">&#39;_</span>&gt;,
    ) {
        <span class="kw">let </span>(request, response_sx) = request.into_parts();
        <span class="kw">let </span>response = request.repeat(<span class="number">2</span>);
        response_sx.send(response, connection).<span class="kw">await</span>.ok();
    }
}</code></pre></div>
<h3 id="concurrent-handler"><a href="#concurrent-handler">Concurrent handler</a></h3>
<p>In this implementation, several requests can be handled simultaneously. As a downside,
sending response is not atomic with updating the worker cursor position (i.e.,
only “at least once” request processing is guaranteed).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>ConcurrentHandler&lt;P&gt; {
    connection_pool: <span class="prelude-ty">Option</span>&lt;P&gt;,
    <span class="comment">// other fields snipped
</span>}

<span class="kw">impl</span>&lt;P: WorkerStoragePool + Clone&gt; WorkerInterface <span class="kw">for </span>ConcurrentHandler&lt;P&gt; {
    <span class="kw">type </span>Request = String;
    <span class="kw">type </span>Response = String;
    <span class="kw">type </span>Codec = Json;
}

<span class="attr">#[async_trait]
</span><span class="kw">impl</span>&lt;P: WorkerStoragePool + Clone&gt; HandleRequest&lt;P&gt; <span class="kw">for </span>ConcurrentHandler&lt;P&gt; {
    <span class="kw">async fn </span>initialize(<span class="kw-2">&amp;mut </span><span class="self">self</span>, connection_pool: <span class="kw-2">&amp;</span>P) {
        <span class="self">self</span>.connection_pool = <span class="prelude-val">Some</span>(connection_pool.clone());
    }

    <span class="kw">async fn </span>handle_request(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        request: Request&lt;<span class="self">Self</span>&gt;,
        _connection: <span class="kw-2">&amp;mut </span>P::Connection&lt;<span class="lifetime">&#39;_</span>&gt;,
    ) {
        <span class="kw">let </span>(request, response_sx) = request.into_parts();
        <span class="kw">let </span>connection_pool = <span class="self">self</span>.connection_pool.clone().unwrap();
        tokio::task::spawn(<span class="kw">async move </span>{
            <span class="kw">let </span>response = request.repeat(<span class="number">2</span>);
            <span class="kw">let </span><span class="kw-2">mut </span>connection = connection_pool.connect().<span class="kw">await</span>;
            response_sx.send(response, <span class="kw-2">&amp;mut </span>connection).<span class="kw">await</span>.ok();
            connection.release().<span class="kw">await</span>;
        });
    }
}</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Cancellation.html" title="struct tardigrade_worker::Cancellation">Cancellation</a></div><div class="desc docblock-short">Information about a request cancellation.</div></li><li><div class="item-name"><a class="struct" href="struct.FnHandler.html" title="struct tardigrade_worker::FnHandler">FnHandler</a></div><div class="desc docblock-short"><a href="trait.HandleRequest.html" title="trait tardigrade_worker::HandleRequest">Worker handler</a> based on a function. Mostly useful for quick prototyping
and testing.</div></li><li><div class="item-name"><a class="struct" href="struct.Request.html" title="struct tardigrade_worker::Request">Request</a></div><div class="desc docblock-short">Request payload together with additional metadata allowing to identify the request.</div></li><li><div class="item-name"><a class="struct" href="struct.ResponseSender.html" title="struct tardigrade_worker::ResponseSender">ResponseSender</a></div><div class="desc docblock-short">Sender of responses for a <a href="trait.HandleRequest.html" title="trait tardigrade_worker::HandleRequest">handler</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Worker.html" title="struct tardigrade_worker::Worker">Worker</a></div><div class="desc docblock-short">Worker encapsulating a handler and a connection to the Tardigrade runtime.</div></li><li><div class="item-name"><a class="struct" href="struct.WorkerRecord.html" title="struct tardigrade_worker::WorkerRecord">WorkerRecord</a></div><div class="desc docblock-short">Storage record for a worker.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.HandleRequest.html" title="trait tardigrade_worker::HandleRequest">HandleRequest</a></div><div class="desc docblock-short">Handler of requests of a certain type.</div></li><li><div class="item-name"><a class="trait" href="trait.WorkerInterface.html" title="trait tardigrade_worker::WorkerInterface">WorkerInterface</a></div><div class="desc docblock-short">Interface of a worker that can handle requests of a certain type.</div></li><li><div class="item-name"><a class="trait" href="trait.WorkerStorageConnection.html" title="trait tardigrade_worker::WorkerStorageConnection">WorkerStorageConnection</a></div><div class="desc docblock-short">Read-write connection to the worker storage.</div></li><li><div class="item-name"><a class="trait" href="trait.WorkerStoragePool.html" title="trait tardigrade_worker::WorkerStoragePool">WorkerStoragePool</a></div><div class="desc docblock-short">Connection pool for the worker storage.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Aliases</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.MessageStream.html" title="type tardigrade_worker::MessageStream">MessageStream</a></div><div class="desc docblock-short">Stream of messages together with their indices.</div></li></ul></section></div></main></body></html>